- langchain
    - [x] https://docs.langchain.com/oss/python/langchain/structured-output
        - allows agents to return data in a specific, predictable format
        - `create_agent` handles structured output automatically
        - when the model generates the structured data, it’s captured, validated, and returned in the `structured_response` key of the agent’s state
        - Response formats
            - ProviderStrategy[StructuredResponseT]
                - Uses provider-native structured output
                - provides high reliability and strict validation
                - fields
                    - `schema` - The schema defining the structured output format.
                    - `strict` - Optional, enables strict schema adherence.
            - ToolStrategy[StructuredResponseT]
                - Uses tool calling for structured output
                - fields
                    - `schema` - The schema defining the structured output format
                    - `tool_message_content` - Custom content for the tool message returned when structured output is generated
                    - `handle_errors` - Error handling strategy for structured output validation failures.
                - When a model incorrectly calls multiple structured output tools, the agent provides error feedback in a `ToolMessage` and prompts the model to retry
                - When structured output doesn’t match the expected schema, the agent provides specific error feedback
                - error handling strategies - `handle_errors`
                    - True - catch all errors with default error template
                    - a string - the agent will always prompt the model to re-try with this message
                    - an exception type(or tuple of exception types), the agent will only retry (using the default error message) if the exception raised is the specified type (on of the types)
                    - custom error handling function
                    - False - propagating errors
    - [x] https://docs.langchain.com/oss/python/langchain/middleware/custom
        - Hooks
            - Node-style hooks
                - Run sequentially at specific execution points.
                    - before_agent - Before agent starts (once per invocation)
                    - before_model - Before each model call
                    - after_model - After each model response
                    - after_agent - After agent completes (once per invocation)
            - Wrap-style hooks
                - Intercept execution and control when the handler is called.
                    - wrap_model_call - Around each model call
                    - wrap_tool_call - Around each tool call
                - can be called
                    1. zero times (short-circuit)
                    2. once (normal flow)
                    3. multiple times (retry logic)
        - creation ways
            1. Decorator-based middleware
                - when single hook needed
                - when no complex configuration
                1. Node-style:
                    - @before_agent - Runs before agent starts (once per invocation)
                    - @before_model - Runs before each model call
                    - @after_model - Runs after each model response
                    - @after_agent - Runs after agent completes (once per invocation)
                2. Wrap-style:
                    - @wrap_model_call - Wraps each model call with custom logic
                    - @wrap_tool_call - Wraps each tool call with custom logic
                3. Convenience:
                    - @dynamic_prompt - Generates dynamic system prompts
            2. Class-based middleware
                - when both sync and async implementations needed for the same hook
                - when need to combine multiple hooks in a single middleware
                - when complex configuration required (e.g., configurable thresholds, custom models)
                - when need to reuse across projects with init-time configuration
        - Middleware can extend the agent’s state with custom properties.
        - Execution order
            - before_* hooks: First to last
            - after_* hooks: Last to first (reverse)
            - wrap_* hooks: Nested (first middleware wraps all others)
        - To exit early from middleware, return a dictionary with `jump_to`
            - 'end': Jump to the end of the agent execution (or the first after_agent hook)
            - 'tools': Jump to the tools node
            - 'model': Jump to the model node (or the first before_model hook)
        - Best practices
            - each middleware should do one thing well
            - don’t let middleware errors crash the agent
            - Node-style for sequential logic (logging, validation)
            - Wrap-style for control flow (retry, fallback, caching)
            - Clearly document any custom state properties
            - Unit test middleware independently
            - place critical middleware first in the execution order
            - Use built-in middleware when possible
