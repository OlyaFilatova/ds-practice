- [x] https://numpy.org/doc/stable/user/basics.creation.html
    - There are 6 general mechanisms for creating arrays:
        1. Conversion from other Python structures (i.e. lists and tuples)
        2. Intrinsic NumPy array creation functions (e.g. arange, ones, zeros, etc.)
            - NumPy has over 40 built-in functions for creating arrays [link](https://numpy.org/doc/stable/reference/routines.array-creation.html#routines-array-creation)
        3. Replicating, joining, or mutating existing arrays
        4. Reading arrays from disk, either from standard or custom formats
        5. Creating arrays from raw bytes through the use of strings or buffers
        6. Use of special library functions (e.g., SciPy, pandas, and OpenCV)
- [x] https://numpy.org/doc/stable/user/basics.indexing.html
    - note that x[0, 2] == x[0][2] though the second case is more inefficient as a new temporary array is created after the first index that is subsequently indexed by 2.
    - Basic slicing extends Python’s basic concept of slicing to N dimensions
        - The basic slice syntax is i:j:k where i is the starting index, j is the stopping index, and k is the step
        - For example, x[1:10:5, ::-1] can also be implemented as obj = (slice(1, 10, 5), slice(None, None, -1)); x[obj] 
    - arrays generated by basic slicing are always views of the original array
    - Ellipsis expands to the number of : objects needed for the selection tuple to index all dimensions. There may only be a single ellipsis present.
    - Ellipsis expands to the number of : objects needed for the selection tuple to index all dimensions. In most cases, this means that the length of the expanded selection tuple is x.ndim. There may only be a single ellipsis present.  newaxis is an alias for None.
    - There are two types of advanced indexing: integer and Boolean.
        - Advanced indexing always returns a copy of the data
        - Advanced indexing is triggered when the selection object, obj, is a non-tuple sequence object, an ndarray (of data type integer or bool), or a tuple with at least one sequence object or ndarray (of data type integer or bool)
        - `x[(1, 2, 3),]` is fundamentally different than `x[(1, 2, 3)]`. The latter is equivalent to `x[1, 2, 3]` which will trigger basic selection while the former will trigger advanced indexing.
        - Integer array indexing allows selection of arbitrary items in the array based on their N-dimensional index.
        - Boolean array indexing occurs when obj is an array object of Boolean type, such as may be returned from comparison operators
            - A common use case for this is filtering for desired element values
            - when the boolean array has fewer dimensions than the array being indexed, this is equivalent to x[b, ...]
    - The easiest way to understand a combination of multiple advanced indices may be to think in terms of the resulting shape.
    - If the ndarray object is a structured array the fields of the array can be accessed by indexing the array with strings, dictionary-like.
    - x.flat returns an iterator that will iterate over the entire array
    - it is permitted to assign a constant to a slice or an array of the right size
    - Note that assignments may result in changes if assigning higher types to lower types or even exceptions
    - Note that here `x[np.array([1, 1, 3, 1])] += 1` element under index 1 will be incremented once (not 3 times)
- [x] https://numpy.org/doc/stable/user/basics.io.genfromtxt.html
    - runs two main loops.
        1. converts each line of the file in a sequence of strings.
        2. converts each string to the appropriate data type.
        - This mechanism is slower than a single loop, but gives more flexibility. (In particular, it is able to take missing data into account)
    - Recognized file types are text files and archives (gzip, bz2, bzip2). The type of the archive is determined from the extension of the file.
    - data can be a string, a list of strings, a generator or an open file-like object with a read method.
        - single string is assumed to be the name of a local or remote file
        - a list of strings or a generator returning strings - each string is treated as one line in a file
        - the URL of a remote file - the file is automatically downloaded to the current directory and opened
    - Empty or commented lines are skipped
    - skip_header, skip_footer - allows skipping several lines at the start or end 
    - usecols - allows choosing columns to import
    - can set custom conversion function for a column
    - missing_values argument is used to recognize missing data and a second argument
    - filling_values, is used to process these missing data
    - to keep track of the occurrence of missing data by constructing a boolean mask set the optional argument usemask to True
- [x] https://numpy.org/doc/stable/user/basics.types.html
    - NumPy numerical types are instances of numpy.dtype (data-type) objects, each having unique characteristics
    - In addition to numerical types, NumPy also supports storing unicode strings, via the numpy.str_ dtype (U character code), null-terminated byte sequences via numpy.bytes_ (S character code), and arbitrary byte sequences, via numpy.void (V character code)
        - fixed-width data types
        - parameterized by a width, in either bytes or unicode points
        - If you need to store and round-trip any trailing null bytes, you will need to use an unstructured void data type
    - NumPy generally returns elements of arrays as array scalars
        - a scalar with an associated dtype
    - Array scalars differ from Python scalars, but for the most part they can be used interchangeably
        - integer array scalars cannot act as indices for lists and tuples
        - There are some exceptions, such as when code requires very specific attributes of a scalar or when it checks specifically whether a value is a Python scalar
        - converting array scalars to Python scalars can be done using the corresponding Python type function (e.g., int, float, complex, str).
    - The behaviour of NumPy and Python integer types differs significantly for integer overflows
        - Python integers may expand to accommodate any integer and will not overflow
        - NumPy provides numpy.iinfo and numpy.finfo to verify the minimum or maximum values of NumPy integer and floating point values respectively
        - If 64-bit integers are still too small the result may be cast to a floating point number. Floating point numbers offer a larger, but inexact, range of possible values
    - floating-point arithmetic can introduce small inaccuracies
        - it’s advisable to use functions like np.isclose to compare values, rather than checking for exact equality
        - NumPy does not provide a dtype with more precision than C’s `long double`
        - Be warned that even if `numpy.longdouble` offers more precision than python float, it is easy to lose that extra precision, since python often forces values to pass through float.
            - For example, the % formatting operator requires its arguments to be converted to standard python types, and it is therefore impossible to preserve extended precision even if many decimal places are requested.
- [x] https://numpy.org/doc/stable/user/basics.broadcasting.html
    - The term broadcasting describes how NumPy treats arrays with different shapes during arithmetic operations.
    - the smaller array is “broadcast” across the larger array so that they have compatible shapes
    - There are cases where broadcasting is a bad idea because it leads to inefficient use of memory that slows computation.
    - The simplest broadcasting example occurs when an array and a scalar value are combined in an operation
        - the scalar behaves as an array of same length as the array and has each element equal to the scalar
    - Two dimensions are compatible when they are equal, or one of them is 1. Otherwise `ValueError: operands could not be broadcast together` exception is thrown.
    - Input arrays do not need to have the same number of dimensions
        - The resulting array will have the same number of dimensions as the input array with the greatest number of dimensions
        - missing dimensions are assumed to have size one
        - In some cases, broadcasting stretches both arrays to form an output array larger than either of the initial arrays
- [x] https://numpy.org/doc/stable/user/basics.copies.html
    - When operating on NumPy arrays, it is possible to access the internal data buffer directly using a view without copying data around
    - The NumPy array is a data structure consisting of two parts
        1. the contiguous data buffer with the actual data elements
        2. the metadata that contains information about the data buffer
            - includes data type, strides, and other important information that helps manipulate the ndarray easily
    - It is possible to access the array differently by just changing certain metadata like stride and dtype without changing the data buffer
        - these new arrays are called views
        - A view can be forced through the ndarray.view method.
    - When a new array is created by duplicating the data buffer as well as the metadata, it is called a copy.
        - A copy can be forced by using ndarray.copy
    - basic indexing always creates views
    - advanced indexing always creates copies
    - The base attribute of a view returns the original array while it returns None for a copy.
        - the base attribute should not be used to determine if an ndarray object is new; only if it is a view or a copy of another ndarray
- [x] https://numpy.org/doc/stable/user/basics.strings.html
    - While NumPy is primarily a numerical library, it is often convenient to work with NumPy arrays of strings or bytes.
    - fixed-width data types are used as the default dtype for strings and bytestrings (numpy.str_, numpy.bytes_, and numpy.void)
    - numpy.dtypes.StringDType, which stores variable-width string data in a UTF-8 encoding in a NumPy array
    - StringDType supports round-trip casts between numpy.str_, numpy.bytes_, and numpy.void
        - Casting to a fixed-width string is most useful when strings need to be memory-mapped in an ndarray or when a fixed-width string is needed for reading and writing to a columnar data format with a known maximum string length.
    - to indicate with a special label that a value is missing pass na_object as a keyword argument for the initializer
        - The na_object can be any arbitrary python object
    - NumPy has special handling for NaN-like sentinels and string sentinels.
        - A NaN-like sentinel returns itself as the result of arithmetic operations.
        - NaN-like sentinels inherit these behaviors in string operations.
        - NaN-like sentinels sort to the end of the array
        - Other objects, such as None are also supported as missing data sentinels. If any missing data are present in an array using such a sentinel, then string operations will raise an error
    - By default, non-string data are coerced to strings
        - an instance of the DType can be created that disables string coercion by setting coerce=False in the initializer

NOTE: circle back to these pages several times, especially when using numpy at work