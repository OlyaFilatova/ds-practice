- [x] https://docs.opencv.org/4.x/dd/d43/tutorial_py_video_display.html
    - capture live stream with a camera
    - read video file
    - show frames as video
    - save video
    - access and set video features
    - Sometimes, cap may not have initialized the capture. In that case, this code shows an error. You can check whether it is initialized or not by the method cap.isOpened(). If it is True, OK. Otherwise open it using cap.open()
- [x] https://docs.opencv.org/4.x/dc/da5/tutorial_py_drawing_functions.html
    - draw line, circle, rectangle, ellipse, polygon, write text
- [x] https://docs.opencv.org/4.x/db/d5b/tutorial_py_mouse_handling.html
    - handling mouse events
        - example draw a circle on an image wherever we double-click on it
    - listing available events
- [x] https://docs.opencv.org/4.x/d9/dc8/tutorial_py_trackbar.html
    - using trackbar to select value in a range
    - using trackbar as a switch
- [x] https://docs.opencv.org/4.x/d3/df2/tutorial_py_basic_ops.html
    - Access pixel values and modify them
        - get pixel channel values
        - update one or all channels for a pixel
    - Access image properties
        - width, height and amount of channels
        - If an image is grayscale, the tuple returned contains only the number of rows and column
        - total number of pixels
        - data type
    - Set a Region of Interest (ROI)
        - obtained using Numpy indexing
    - Split and merge images
        - cv.split() is a costly operation (in terms of time). So use it only if necessary. Otherwise go for Numpy indexing.
    - Making Borders for Images using copyMakeBorder()
        - has applications for convolution operation, zero padding etc. 
    - A good knowledge of Numpy is required to write better optimized code with OpenCV.
    - a large number of errors in OpenCV-Python code are caused by invalid datatype.
- [x] https://docs.opencv.org/4.x/d0/d86/tutorial_py_image_arithmetics.html
    - Image Addition
        - Both images should be of same depth and type, or the second image can just be a scalar value.
        - OpenCV addition is a saturated operation while Numpy addition is a modulo operation.
    - Image Blending
        - This is also image addition, but different weights are given to images
        - give a feeling of blending or transparency
        - can perform transition between one image to another
    - Bitwise Operations
        - useful while extracting any part of the image, defining and working with non-rectangular ROI's, and etc.
- [x] https://docs.opencv.org/4.x/dc/d71/tutorial_py_optimization.html
    - Measuring Performance with OpenCV
        - the number of clock-cycles after a reference event (like the moment the machine was switched ON) to the moment this function is called
        - the frequency of clock-cycles, or the number of clock-cycles per second
    - Default Optimization in OpenCV
        - Many of the OpenCV functions are optimized using SSE2, AVX, etc.
            - check if it is enabled/disabled
            - enable/disable it
    - Measuring Performance in IPython
        - timeit
    - Normally, OpenCV functions are faster than Numpy functions. So for same operation, OpenCV functions are preferred. But, there can be exceptions, especially when Numpy works with views instead of copies.
    - Performance Optimization Techniques
        - implement the algorithm in a simple manner. Once it is working, profile it, find the bottlenecks, and optimize them
        1. Avoid using loops in Python as much as possible, especially double/triple loops etc. They are inherently slow.
        2. Vectorize the algorithm/code to the maximum extent possible, because Numpy and OpenCV are optimized for vector operations.
        3. Exploit the cache coherence.
        4. Never make copies of an array unless it is necessary. Try to use views instead.

- [x] https://docs.opencv.org/4.x/df/d9d/tutorial_py_colorspaces.html
    - convert images from one color-space to another, like BGR <-> Gray, BGR <-> HSV, etc.
        - There are more than 150 color-space conversion methods available
    - extract a colored object in a video
        - In HSV, it is easier to represent a color than in BGR color-space
        - a trick to finding HSV values to track
- [x] https://docs.opencv.org/4.x/da/d6e/tutorial_py_geometric_transformations.html
    - applying geometric transformations to images, like translation, rotation, affine transformation etc.
    - scaling
        - resizing
    - Translation
        - shifting of an object's location
    - Rotation
        - scaled rotation with adjustable center of rotation so that you can rotate at any location
    - affine transformation
        - all parallel lines in the original image are still be parallel in the output image
    - Perspective Transformation
        - need a 3x3 transformation matrix
        - Straight lines will remain straight even after the transformation
        - need 4 points on the input image and corresponding points on the output image. Among these 4 points, 3 of them should not be collinear
- [x] https://docs.opencv.org/4.x/d7/d4d/tutorial_py_thresholding.html
    - Simple Thresholding
        - For every pixel, the same threshold value is applied
            - If the pixel value is smaller than or equal to the threshold, it is set to 0, otherwise it is set to a maximum value.
    - Adaptive Thresholding
        - the algorithm determines the threshold for a pixel based on a small region around it
        - gives better results for images with varying illumination
    - Otsu's Binarization
        - Otsu's method avoids having to choose a threshold value and determines it automatically
- [x] https://docs.opencv.org/4.x/d4/d13/tutorial_py_filtering.html
    - Apply custom-made filters to images (2D convolution)
    - LPF helps in removing noise, blurring images, etc.
    - HPF filters help in finding edges in images
    - Blur images with various low pass filters
        - averaging
        - gaussian blurring
            - effective in removing Gaussian noise from an image
        - Median Blurring
            - takes the median of all the pixels under the kernel area and the central element is replaced with this median value
            - highly effective against salt-and-pepper noise in an image
        - Bilateral Filtering
            - highly effective in noise removal while keeping edges sharp
            - the operation is slower compared to other filters
- [x] https://docs.opencv.org/4.x/d9/d61/tutorial_py_morphological_ops.html
    - different morphological operations like Erosion, Dilation, Opening, Closing etc.
    - Morphological transformations are some simple operations based on the image shape.
        - It is normally performed on binary images.
    - Erosion
        - erodes away the boundaries of foreground object (Always try to keep foreground in white)
        - useful for removing small white noises (as we have seen in colorspace chapter), detach two connected objects etc.
    - Dilation
        - opposite of erosion
        - Normally, in cases like noise removal, erosion is followed by dilation. Because, erosion removes white noises, but it also shrinks our object.
    - Opening
        - is just another name of erosion followed by dilation.
    - Closing
        - is reverse of Opening, Dilation followed by Erosion
    - Morphological Gradient
        - is the difference between dilation and erosion of an image.
    - Top Hat
        - is the difference between input image and Opening of the image.
    - Black Hat
        - is the difference between the closing of the input image and input image.
    - Structuring Element
        - when need elliptical/circular shaped kernels.
- [x] https://docs.opencv.org/4.x/d5/d0f/tutorial_py_gradients.html
    - OpenCV provides three types of gradient filters or High-pass filters, Sobel, Scharr and Laplacian.
    - Sobel and Scharr Derivatives
    - Sobel operators is a joint Gaussian smoothing plus differentiation operation, so it is more resistant to noise
        - can specify the direction of derivatives to be taken, vertical or horizontal and the size of kernel
        - If ksize = -1, a 3x3 Scharr filter is used which gives better results than 3x3 Sobel filter
    - Black-to-White transition is taken as Positive slope (it has a positive value) while White-to-Black transition is taken as a Negative slope (It has negative value). So when you convert data to np.uint8, all negative slopes are made zero. In simple words, you miss that edge.
- [x] https://docs.opencv.org/4.x/da/d22/tutorial_py_canny.html
    - Canny Edge Detection
        - the result you get is a binary image with "thin edges".
    - is a multi-stage algorithm
        1. Noise Reduction with a 5x5 Gaussian filter.
        2. Finding Intensity Gradient of the Image
            - filtered with a Sobel kernel in both horizontal and vertical direction
            - find edge gradient and direction for each pixel
            - Gradient direction is always perpendicular to edges
            - full scan of image is done to remove any unwanted pixels
        3. Non-maximum Suppression
        - Hysteresis Thresholding
            - decides which edges are really edges and which are not using intesity gradient values.
- [x] https://docs.opencv.org/4.x/dc/dff/tutorial_py_pyramids.html
    - Image Pyramid - a set of the same image with different resolutions
    1. Gaussian Pyramid
        - area reduces to one-fourth of original area (called an Octave)
    2. Laplacian Pyramid
        - are formed from the Gaussian Pyramids
        - edge images only
    - One application of Pyramids is Image Blending
